- 초보 개발자의 고군분투
	- Device/ version fragmentation : 무엇을 상상하던 안드로이드는 예기치 못한곳에서 뒤통수를 침
	- 짜증나는 비동기 : 가끔은 전혀 다른 방향으로 로직이 실행된다. 근데 또 매번 그러는건 아니다
	- 알다가도 모를 생명주기 문제
	- 구글은 계속 새로운걸 내놓는다

- 그러나 고군분투 하다보면 결국 실력이 올라갈 것이다

- 레벨업 하며 느낀 점
	- 영어 자료로 눈을 돌리면 자료는 넘친다. 스택오버플로, 튜토리얼 등
	- 어찌 하다보니 노하우도 생겼다.


- 그러나 우리를 기다리는건 슬럼프
	- 이전과 같은 속도로 실력이 늘지 않는다
	- 인터넷엔 초급 이상의 자료는 별로 없다
	- 괜찮은 자료를 찾았다 싶으면 뭔소린지 알 수가 없다

- 하.. 누가 알려줬으면 좋겠다

- 클린 아키텍처
	- 아니 하라는게 왜이리 많아?
	- 동그란 과녁 그림 그만 보고 싶다

- MVP.. 넌 뭐야
	- MVVM 보단 쉽다는데..
	- 잘 적용하고 있는거 맞아.?

- RxJava
	- 뭐야 도데체!!
	- 기능은 또 왜이리 많은거야

- 의존성 주입
	- 간단한거 같은데 왜이리 어려워?

- TDD
	- 하면 좋다는데..
	- 유닛 테스트 어떻게 하는거야..


- 주화입마에 빠진 시니어 개발자의 전형적 증상
	- 비관주의 : 그거 없어도 이제까지 잘 개발해왔어
	- 팔랑귀 : 새로운게 나왔어? 당장 써보자
	- Low-hanging fruit : 쉬운 문제에만 집착. 어려운건 안해

---

- 개발자의 개성에 따라 많은 스킬 트리가 있찌만 이 두가지를 생각해보자

- Solution Provider 잘하는 개발자
 	- 다른 사람이라면 구현하지 못할 것이나 훨씬 빠르거나 작은 사이즈로 동작하게 만드는 사람
	- 언어의 깊은 원리와 설계 철학에 대한 이해가 있다
	- Dalvik의 동작 원리에 대한 이해가 있다
	- 안드로이드가 화면을 렌더링 하는 매커니즘을 이해한다
	- 등등의 실력

- Architect 잘하는 개발자
	- readme 파일 외에 아무 설명 없이도 다른 개발자에게 인수인계 할 수 있도록 가독성 업
	- 내 코드를 1년뒤에 다시 봤을 때 곧바로 이해할 수 있다
	- 큰 규모의 구조수정도 1~2일 내에 해낼 수 있다
	- 기본 구조가 매우 견고하게 작성한다. -> 잘못된 방식으로 구현하기 어려울 정도로 구조를 만들 줄 안다

---

- 안드로메다를 헤매는 중급 개발자들을 위한 안내

- 시작이 반
	- 비관주의를 버리고 일단 부딪혀 봐
	- 해보지 않으면 이해하기 힘들어
	- 시작은 튜토리얼이 많아서 하기 쉬울거야

- 두 사람이 각자 갖고 있는 사과를 교환하면 여전히 하나, 아이디어를 교환하면 각자 두개 : George Bernard Shaw

- 공유의 힘!
	- 노하우던 말할거리던 당신의 지식을 꾸준히 공유하라
	- 비슷한 관심사의 엔지니어를 꾸준히 만나봐
	- 블로그를 해보는건 어떻니
		- 단순 정리말고 자신의 생각이 들어간 글이 좋단다

- 일본의 경우
	- 블로그를 통한 공유가 일상화되어 있음
	- 공부회라는 지역단위 세미나가 활성화 되어 있음
	- 모쿠모쿠 모임도 있고 Network Party도 많다

---

- 디자인패턴 얘기 시작!

- MVC는 악마가 아니다
	- 모델과 뷰는 일종의 레고블럭임
		- 모델 계층에서는 비즈니스 로직을, 뷰에는 UI 로직을 제공함
	- 조립은 컨트롤러가 담당함
		- 어떤 뷰를 보여줄 것인지를 경정해서 모델에서 받은 데이터를 뷰에게 넘겨줌
		- 또한 에러를 어떻게 처리할지 결정해서 뷰로 넘겨줌

- 근데 왜 안드로이드는 MVC가 나쁘다고 하는가
	- MVC가 나쁜게 아니라 안드로이드가 나쁜거야
	- 모바일 환경 자체가 문제임
		- 복잡한 비동기 처리가 있고 라이프 사이클 처리도 해야됨. 매우 복잡함
	- 안드로이드의 문제도 있음
		- 뷰와 컨트롤러의 분리가 애매함
		- 결국 모든 일들을 액티비티나 프래그먼트에서 다 해야함
		- 결국 컨트롤러가 비대해지고 유닛 테스트를 만들기 매우 까다로워 짐
		- 테스트를 하고 안하고가 문제가 아니라 테스트가 까다로운 설계자체가 문제인 거임
		- 객체 지향에서 말하는 결합도 낮게하라는게 안지켜짐
	- 그 결과 최악의 가독성의 코드가 나온다
		- 상대방을 이해 못시킨다. 애초에 나도 헷갈림
		- 하나의 클래스가 너무 많은 역할을 함. 유지보수, 수정, 가독성 모두 망함

- 그럼 MVP를 도입해서 해결해보자!
	- 90년대에 마틴 파울러가 소개한 개념
	- 안드로이드 초기부터 많이 전해져 온 아키텍처임
	- 뷰는 비즈니스 로직에 관련된 부분을 관여하지 못하도록 함.
	- 그럼 누가해? 프레젠터가 해
	- ![mvp_pattern](https://user-images.githubusercontent.com/68932465/193197064-e28e4be0-b55c-4d45-a47b-445914d1ce1f.png)
	
- MVP의 장점
	- MVC의 젤 큰 문제인 Fat 컨트롤러를 예방할 수 있다
	- 적절한 책임분리로 인해 가독성과 품질이 올라간다
	- 플랫폼 의존적인 UI 처리는 뷰가 담당하기 때문에 프레젠터는 쉽게 테스트 작성이 가능해졌다
	- 클린 아키텍쳐와 1:1 매핑이 됨

- MVVM은 뭐야?
	- 좀더 복잡하고 오해가 많은 것 같다.
	- 따라서 그전에 MVVM이 아닌게 뭔지? 오해를 풀고 가자

- MVVM의 특징은 Life cycle 이다?
	- 블로그 같은 곳을 보면 매번 나오는 내용이 생명주기다
	- 뷰모델을 쓰면 구성 변경에 어쩌구 저쩌구
	- 근데 이건 AAC(안드로이드 앜텍쳐 컴포넌트)의 특징이지 뷰모델의 특징이 아님
	
- Data Binding?
	- 필수는 아니지만 난 쓰는게 좋다고 생각함

- RxMVVM?
	- 역시 필수는 아니지만 Rx 없이는 매우 불편함
	- 콜백도 훌륭하긴 하지만.. 리액티브 최고!

- 용어에서 오는 혼란
	- 뷰모델은 애초에 잘못된 개념이다?
	- 뷰모델이라고 하면 머리에 떠오르는건 모델인데 뷰에 특화된? 모델이라 생각한다
	- 모델과 같이 작은 단위로 쪼개져 있찌 않은데가가 별게 다 들어가 있는 형태라 오해할 수 있음
	- 뷰모델은 뷰를 위한 모델이란 개념과 단방향 프레젠터라는  두개의 개념을 한번에 갖고 있음

- 그래서 뷰모델이 뭐여
	- 이것도 마틴 파울러가 말함
	- 단방향 중간자임
		- 프레젠터와 유사하나 뷰모델은 뷰를 모름
		- 뷰는 뷰모델을 호출하되 콜백이나 Observable 형태로 받음

- 그래서 MVVM vs MVP는 엄마가 좋냐 아빠가 좋냐 같다.
	- 근데 이건 18년 강의라 지금은 많이 다르지 않을까
	- 둘다 훌륭한 구조임. 압도적인 우위는 없음.
	- 둘 사이의 차이는 상대적임. 프로젝트 성격에 따라 다름

- MVP가 더 나은점
	- 러닝커브가 낮음.
	- RxJava를 안써도 훌륭한 구조를 만들 수 있긴 함

- MVVM은!!
	- 초기 진입장벽이 좀 높음
		- 기존의 개발 개념에 비해 패러다임 전환이 필요함
	- 큰 회사들이 MVVM을 채택하는 이유는 뷰의 상태관리가 복잡한 앱이기 때문에 뷰모델에서 처리하는게 더 자연스러움
	- AAC의 후광 효과를 받을 수 있음
	- Cross 플랫폼 구현에 좀 더 유리함. 코틀린을 스위프트로 옮기는 것만으로 코드를 많이 재사용 가능함

- MVP와 MVVM의 공통의 장점
	- 개발 속도가 매우 빨라짐
		- 물론 초기에는 몇배로 느려질 수 있음
	- 코드 변경에 대한 두려움이 없어짐
	- 기획자가 급격히 변해도 웃을 수 있음
	- 1년뒤에 코드를 봐도 이해할 수 있따	
	- 다른 엔지니어에게 코드를 보여줘도 안부끄럽다

---

- 성장 했다고 생각했으나..
	- 프로젝트 사이즈가 커지면서 지저분해지는 코드..
	- 차라리 쓰지 말걸..

- 마지막 장!

- Fat Presenter 문제
	- 이제는 프레젠터가 너무 많은 일을 한다
	- 테스트 케이스를 만들기가 힘들다
	- 주된 원인 중 하나는 프레젠터를 뷰와 명확히 분리하지 않았기 때문임

- 해결책 고민
	- 크게 고민하지 않아도 뷰와 프레젠터를 잘못 구현하기 어렵도록 하는 장치가 필요하다
	- 뷰는 이벤트를 발생시키고 UI를 그려주는 역할만. 비즈니스 로직이나 모델이 끼어들 수 있는 여지를 주지 말자
	- 프레젠터가 뷰의 세부사항을 알 수 없도록 하자
	- 이를 위해 나온 것이 Contract 패턴

- Contract Pattern
	- 뷰를 인터페이스로 분리함
		- Mock Object를 통한 유닛 테스트가 매우 쉬워짐
	- 프레젠터는 비즈니스 로직 처리만 담당
	- 뷰는 그리기만 담당
	- 데이터의 분리도 함께 이뤄짐. 뷰는 모델에 대해 알 필요도 알 수도 없음
	- 대부분은 프레젠터도 인터페이스로 분리함

- MVVM의 Passive View
	- 수동 뷰?
	- MVI에서는 Dubm Client라고 부름. 멍청한 클라이언트. 오직 그리기만 담당
	- 뷰는 플랫폼 의존적인 그리기 이외에는 아무것도 알 수 없도록 함 

- 음.. 그럼 뷰모델이 거대해 지는데 괜찮나?
	- 괜찮진 않지만 의도한 결과임
	- MVVM은 더 나은 구조로 가기 위한 중요한 가교?임
	- 누구는 MVVM은 아키텍처가 아니라고도 함

- 비즈니스 로직의 비대화
	- 프레젠터나 뷰모델의 도메인 로직이 감당할 수 없는 크기가 되는 상황이 온다
	- 가장 좋은 해결책은 단일 책임원칙을 적용하는 것
		- 하나의 클래스는 하나의 책임
	- 모범 답안은 바로 클린 아키텍처
	- 프레젠터에서 도메인 로직을 분리해보자
	- 데이터 계층도 세분화하여 더욱 추상화된 형태의 구조로 만들자

- 클린 아키텍처의 장점
	- 명확한 단일 책임 원칙을 지킬 수 있다 
	- 프레젠터, 도메인, 데이터 계층의 분리로 인해 전체 로직의 흐름이 일목요연 해짐, 따라서 가독성이 올라감
	- 특정 클래스가 비대해지는 것도 막음
	- 각 계층간 구분이 명확하므로 각 영향 범위도 명확함
	- 그러나 클래스 양이 많이 증가함 -> 한번에 다 하려하면 개발속도 저하화 버그 양산이 일어날 수 있다

---

- 몇가지 난제들
	
- 프레젠터의 비즈니스 로직과 유스케이스의 비즈니스 로직은 뭐가 다른가?
	- 큰 차이 : 도메인 로직이 유스케이스에 들어감
	- 사업 부서 사람들도 알고 있어야 하는 로직이 도메인 로직임

- MVP 패턴에서의 리사이클러뷰
	- 어댑터를 어떻게 대해야 하나? 정답은 없다
	- 1. 액티비티가 어댑터를 제어
	- 2. 어댑터와 매핑되는 프레젠터를 구현
	- 개발 아이템과 각각 1:1로 매핑되는 작은 프레젠터를 구현

- MVVM 에서의 리사이클러 뷰
	- 데이터 바인딩으로 그대로 뷰모델에 연결 가능
	- 복잡한 경우가 아니라면 어댑터에 뷰모델을 연결
